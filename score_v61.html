<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>TTFL ‚Äî Live Score Card</title>

  <!-- iPhone "Add to Home Screen" nice behavior -->
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="theme-color" content="#0b0f14" />

  <style>
    :root{
      --bg:#0b0f14;
      --card:rgba(255,255,255,.06);
      --card2:rgba(255,255,255,.08);
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.65);
      --line:rgba(255,255,255,.10);
      --blue:#1f63ff;
      --orange:#ff9a3c;
      --blueDark:#0b2f63;
      --blueDark2:#082244;
      --orangeDark:#5a2f00;
      --orangeDark2:#3d2100;
      --historyOrange:#ff9a3c;
      /* Darker score tiles (match watch-style look) */
      --blueDark:#0c2a55;
      --orangeDark:#5a3a12;
      --good:#41d38a;
      --bad:#ff5d5d;
      --shadow: 0 24px 60px rgba(0,0,0,.45);
      --radius: 22px;
      --pad: 18px;
      --font: -apple-system, BlinkMacSystemFont, "SF Pro Text", "SF Pro Display", Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }

    html,body{height:100%;}
    body{
      margin:0;
      font-family: var(--font);
      background: radial-gradient(1200px 600px at 20% -10%, rgba(47,123,255,.22), transparent 55%),
                  radial-gradient(1000px 600px at 90% 10%, rgba(255,154,60,.18), transparent 60%),
                  linear-gradient(180deg, #0b0f14 0%, #070a0f 100%);
      color:var(--text);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    .wrap{
      max-width: 980px;
      margin: 0 auto;
      padding: max(14px, env(safe-area-inset-top)) 14px max(14px, env(safe-area-inset-bottom));
    }

    .topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding: 10px 10px 14px;
    }
    .brand{
      display:flex; align-items:center; gap:10px;
      font-weight: 800;
      letter-spacing:.2px;
      font-size: 11px;
    }
    .dot{
      width:10px;height:10px;border-radius:99px;background:rgba(255,255,255,.35);
      box-shadow: 0 0 0 4px rgba(255,255,255,.06);
    }
    .pill{
      display:flex; align-items:center; gap:8px;
      padding: 8px 12px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.05);
      border-radius: 999px;
      font-size: 13px;
      color: var(--muted);
      white-space:nowrap;
    }
    .pill b{color:var(--text); font-weight:700;}
    .statusDot{
      width:8px;height:8px;border-radius:99px;background:rgba(255,255,255,.35);
    }

    .grid{
      display:grid;
      grid-template-columns: 1fr;
      gap: 14px;
    }

    @media (min-width: 900px){
      .grid{grid-template-columns: 1.2fr .8fr;}
    }

    .panel{
      background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.04));
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }

    .panelHeader{
      padding: 14px var(--pad);
      border-bottom: 1px solid var(--line);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .panelHeader h2{
      margin:0; font-size: 18px; letter-spacing:.2px;
    }
    .panelHeader .sub{
      margin:0; margin-top:4px; font-size: 13px; color: var(--muted);
    }
    .panelBody{ padding: var(--pad); }

    .hint{
      color: var(--muted);
      font-size: 13px;
      line-height: 1.35;
      padding: 12px 14px;
      background: rgba(255,255,255,.04);
      border:1px dashed rgba(255,255,255,.18);
      border-radius: 16px;
    }
    .hint strong{ color: var(--text); }
    .hint .stateLine{ display:flex; gap:8px; align-items:center; margin-top:10px; }
    .stateBadge{
      display:inline-flex; align-items:center; gap:8px;
      padding: 7px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
      font-weight: 800;
      color: var(--text);
      font-size: 12px;
      letter-spacing:.2px;
    }
    .stateBadge .miniDot{ width:7px; height:7px; border-radius:99px; background: rgba(255,255,255,.35); }
    .stateBadge.live .miniDot{ background: var(--good); }
    .stateBadge.cancelled .miniDot{ background: var(--bad); }
    .stateBadge.scheduled .miniDot{ background: rgba(255,255,255,.55); }
    .stateBadge.idle .miniDot{ background: rgba(255,255,255,.35); }

    .form{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 14px;
    }
    .field label{
      display:block;
      font-size: 12px;
      color: var(--muted);
      margin: 0 0 8px 2px;
      letter-spacing:.2px;
    }
    input, select{
      width:100%;
      box-sizing:border-box;
      padding: 14px 14px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.18);
      color: var(--text);
      outline:none;
      font-size: 16px; /* iOS zoom prevention */
    }
    input::placeholder{color: rgba(255,255,255,.35);}
    select{appearance:none;}
    .field.full{grid-column: 1 / -1;}

    .btnRow{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 14px;
    }
    .btn{
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: var(--text);
      border-radius: 22px;
      padding: 16px 14px;
      font-weight: 800;
      font-size: 18px;
      letter-spacing:.2px;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .btn.primary{
      background: linear-gradient(180deg, rgba(47,123,255,.35), rgba(47,123,255,.18));
      border-color: rgba(47,123,255,.45);
    }
    .btn.secondary{
      background: rgba(255,255,255,.05);
    }
    .btn:disabled{
      opacity:.45;
      cursor:not-allowed;
    }
    .smallNote{
      margin-top: 10px;
      font-size: 12.5px;
      color: var(--muted);
      text-align:center;
    }

    /* Score board */
    .scoreTop{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      margin-bottom: 10px;
    }
    .matchTitle{
      font-weight:800;
      font-size: 16px;
      letter-spacing:.2px;
      margin:0;
    }
    .matchMeta{
      font-size: 12.5px;
      color: var(--muted);
      margin: 2px 0 0 0;
    }

    .scoreGrid{
      display:grid;
      grid-template-columns: 1fr 34px 1fr;
      align-items:center;
      gap: 12px;
      margin-top: 10px;
    }
    .scoreCard{
      border-radius: 24px;
      padding: 18px 14px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      position:relative;
      overflow:hidden;
    }
    /* Dark blue / dark orange tiles with subtle depth */
    .scoreCard.blue{
      background: #0C2A55;        /* solid dark blue */
      border: 2px solid #1f63ff;
      box-shadow: 0 18px 40px rgba(0,0,0,.45);
    }
    .scoreCard.orange{
      background: #5A2F00;        /* solid dark orange */
      border: 2px solid #ff9a3c;
      box-shadow: 0 18px 40px rgba(0,0,0,.45);
    }

    .nameRow{
      display:flex; align-items:center; justify-content:space-between;
      margin-bottom: 10px;
    }
    .pname{ font-weight:900; font-size: 16px; margin:0; }
    .serve{
      width:16px;
      height:16px;
      border-radius:999px;
      background:#0b5e3c;              /* dark green core */
      box-shadow:
        0 0 8px #00ff9d,
        0 0 18px #00ff9d,
        0 0 28px rgba(0,255,157,.6);
    }
    .bigScore{
      font-size: 72px;
      font-weight: 950;
      line-height: 1;
      text-align:center;
      margin: 2px 0 0;
      letter-spacing: 1px;
      color: #ffffff;   /* pure white */
    }

    .midIcon{
      display:flex; align-items:center; justify-content:center;
      color: rgba(255,255,255,.65);
      font-weight:800;
    }

    .setsRow{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap: 12px;
      margin-top: 14px;
    }
    .setsCol{
      flex:1;
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 18px;
      padding: 12px;
      min-height: 84px;
    }
    .setsLabel{
      font-size: 12px;
      color: var(--muted);
      letter-spacing:.2px;
      margin: 0 0 10px 0;
      text-transform: uppercase;
    }

    .setList{
      display:flex;
      flex-direction:column;
      gap: 8px;
      align-items:center; /* centered */
      justify-content:flex-start;
    }
    
    .setItem{
      width: 100%;
      max-width: 520px;
      display:flex;
      align-items:center;
      justify-content:space-between; /* score left, time right */
      gap: 16px;
      padding: 14px 14px;
      border-radius: 16px;
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.10);
      font-weight: 950;
      letter-spacing:.6px;
      color: var(--historyOrange);
      font-variant-numeric: tabular-nums;
    }
    .setScoreLeft{
      display:flex;
      align-items:center;
      justify-content:flex-start;
      gap: 14px;
      min-width: 0;
      color: var(--historyOrange);
      font-size: 18px;
      line-height: 1;
    }
    .setScoreLeft .vsep{
      opacity:.9;
      font-size: 16px;
      font-weight: 900;
    }
    .setTimeRight{
      min-width: 120px;
      text-align:right;
      color: var(--historyOrange);
      opacity:.98;
      font-size: 16px;
      font-weight: 900;
      letter-spacing:.4px;
      white-space:nowrap;
    }
    .chipA{color: var(--historyOrange);}
    .chipB{color: var(--historyOrange);}
    .sep{color: var(--historyOrange);}


    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 14px;
    }
    .cbtn{
      padding: 14px 12px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      color: var(--text);
      font-weight: 900;
      font-size: 16px;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .cbtn.blue{ border-color: rgba(47,123,255,.45); background: rgba(47,123,255,.18); }
    .cbtn.orange{ border-color: rgba(255,154,60,.45); background: rgba(255,154,60,.15); }
    .cbtn.warn{ border-color: rgba(255,93,93,.45); background: rgba(255,93,93,.12); }
    .cbtn.good{ border-color: rgba(65,211,138,.45); background: rgba(65,211,138,.12); }
    .cbtn.neutral{ border-color: rgba(255,255,255,.12); background: rgba(255,255,255,.06); }

    .footerNote{
      margin-top: 10px;
      font-size: 12px;
      color: var(--muted);
      text-align:center;
    }

    /* Overlay message */
    .toast{
      position: fixed;
      left: 12px; right: 12px;
      bottom: max(12px, env(safe-area-inset-bottom));
      padding: 12px 14px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.55);
      backdrop-filter: blur(10px);
      box-shadow: 0 20px 50px rgba(0,0,0,.45);
      color: var(--text);
      font-weight: 700;
      opacity: 0;
      transform: translateY(10px);
      transition: all .22s ease;
      pointer-events:none;
      z-index: 999;
    }
    .toast.show{opacity:1; transform: translateY(0);}
    .toast small{display:block; font-weight:600; color: var(--muted); margin-top: 4px;}

    /* "Done" result layout */
    .resultTitle{
      text-align:center;
      font-weight: 950;
      font-size: 26px;
      margin: 6px 0 2px;
      letter-spacing:.4px;
    }
    .resultScore{
      display:flex; align-items:center; justify-content:center;
      gap: 10px;
      margin: 10px 0 10px;
      font-weight: 950;
      font-size: 52px;
      letter-spacing: 1px;
    }
    .badge{
      padding: 10px 14px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      min-width: 92px;
      text-align:center;
    }
    .badge.blue{
      background: #0C2A55;
      border-color: rgba(31,99,255,.55);
      color:#ffffff;
    }
    .badge.orange{
      background: #5A2F00;
      border-color: rgba(255,154,60,.55);
      color:#ffffff;
    }
    .doneTop{
      display:flex; justify-content:space-between; align-items:center; margin-bottom: 8px;
      color: var(--muted);
      font-weight: 800;
    }

    @media (max-width: 420px){
      .brand{font-size: 11px;}
      .bigScore{font-size: 58px;}
      .btn{font-size: 17px;}
    }

    
    /* History rows sizing for iPhone */
    
    /* MATCH pill width tuning */
    @media (max-width: 430px){
      
    }
    @media (max-width: 380px){
      
    }
@media (max-width: 430px){
      .setScoreLeft{ font-size: 16px; }
      .setScoreLeft .vsep{ font-size: 14px; }
      .setTimeRight{ font-size: 14px; min-width: 108px; }
    }

/* iPhone landscape: make scores easier to read from far */
    @media (orientation: landscape) and (max-height: 520px){
      .wrap{padding-top: max(10px, env(safe-area-inset-top)); padding-bottom: max(10px, env(safe-area-inset-bottom));}
      .topbar{padding-bottom: 10px;}
      .bigScore{font-size: 110px;}
      .scoreCard{padding: 26px 18px; border-radius: 30px;}
      .matchTitle{font-size: 18px;}
      .resultScore{font-size: 70px;}
      .badge{min-width: 120px; padding: 14px 18px; border-radius: 22px;}
      .resultTitle{font-size: 30px;}
    }
  
        .resultSide{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap: 8px;
    }
    .resultName{
      font-size: 13px;
      font-weight: 900;
      color: rgba(255,255,255,.78);
      letter-spacing:.3px;
      text-transform: uppercase;
      max-width: 130px;
      text-align:center;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .totalTime{
      text-align:center;
      color: rgba(255,255,255,.72);
      font-weight: 900;
      letter-spacing:.3px;
      margin-top: 6px;
      font-size: 13px;
    }

    /* Optional: landscape on iPhone - prioritize score + controls */
    @media (orientation: landscape) and (max-height: 520px){
      .grid{grid-template-columns: 1fr;}
      .grid > .panel:last-child{display:none;}
      .bigScore{font-size: 56px;}
      .controls{grid-template-columns: 1fr 1fr 1fr;}
    }

    /* Match bar (below main score tiles) */
    
    .metaPill{
      padding: 10px 16px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.22);
      color: rgba(255,255,255,.82);
      font-weight: 950;
      letter-spacing: 3px;
      font-size: 14px;
      text-transform: uppercase;
      user-select:none;
    }
    /* MATCH pill (fixed: centered + never wraps) */
    .matchBar{
      grid-column: 1 / -1;           /* span full grid */
      width:100%;
      display:flex;
      align-items:center;
      justify-content:center;
      justify-self: stretch;
      margin-top: 14px;
      margin-bottom: 6px;
      padding: 0 12px;
      box-sizing: border-box;
    }
    .matchPill{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      flex-direction: row;
      flex-wrap: nowrap !important;
      white-space: nowrap !important;
      gap: 14px;
      width: min(520px, 92vw);
      max-width: 520px;
      padding: 12px 26px;
      text-align:center;
      letter-spacing: 2px;
      background: rgba(0,0,0,.28);
      color: rgba(255,255,255,.92);
      border: 1px solid rgba(255,255,255,.14);
      border-radius: 999px;
      user-select:none;
      line-height: 1;
    }
    .matchPill, .matchPill *{ white-space: nowrap !important; }
    .matchPill, .matchPill *{ white-space: nowrap !important; }
    .matchPill .mlabel{ opacity:.85; }
    .matchPill .mdash{ opacity:.7; margin: 0 8px; }

    @media (max-width: 430px){
      .matchPill{
        width: min(430px, 92vw);
        padding: 12px 18px;
        gap: 12px;
        letter-spacing: 2px;
      }
    }
    @media (max-width: 380px){
      .matchPill{
        width: min(380px, 94vw);
        padding: 10px 16px;
        gap: 10px;
        letter-spacing: 1px;
      }
    }

    
    .matchPill .mlabel{opacity:.85; margin-right:0;}
    .matchPill .mdash{opacity:.7; margin: 0 6px;}
    .matchPill span{display:inline-block; white-space:nowrap !important;}
    .matchPill, .matchPill *{ white-space: nowrap !important; }
    
    .matchPulse{
      animation: matchPulse .55s ease-out 0s 1;
    }
    /* iPhone 15 Plus width (430px) + most phones */
@media (max-width: 430px){
  
}

/* Smaller phones */
@media (max-width: 380px){
  
}
    @keyframes matchPulse{
      0%{ transform: scale(1); box-shadow:none; }
      45%{ transform: scale(1.06); box-shadow: 0 0 0 6px rgba(255,255,255,.10), 0 0 26px rgba(255,154,60,.25); }
      100%{ transform: scale(1); box-shadow:none; }
    }

    /* Deuce badge (VERY visible) */
.deuceRow{ grid-column: 1 / -1; width:100%; display:flex; justify-content:center; align-items:center; margin: 16px 0 12px; position: relative; }
.deuceBadge{
  position: relative;
  padding: 14px 26px;
  border-radius: 18px;
  border: 1px solid rgba(255,255,255,.18);
  background: linear-gradient(135deg, rgba(255,0,90,.95), rgba(255,120,0,.90));
  font-weight: 1000;
  font-size: 22px;
  letter-spacing: 6px;
  text-transform: uppercase;
  color: #ffffff;
  box-shadow:
    0 0 22px rgba(255,0,90,.85),
    0 0 70px rgba(255,0,90,.45);
  animation: deucePulse 0.85s ease-in-out infinite;
}
.deuceBadge::after{
  content:"";
  position:absolute;
  inset:-10px;
  border-radius: 24px;
  border: 2px solid rgba(255,140,0,.65);
  animation: deuceRing 1.35s linear infinite;
}
@keyframes deucePulse{
  0%,100%{ transform: scale(1); filter: brightness(1); }
  50%{ transform: scale(1.10); filter: brightness(1.25); }
}
@keyframes deuceRing{
  0%{ opacity:1; transform: scale(1); }
  100%{ opacity:0; transform: scale(1.45); }
}

/* Extra deuce emphasis on the main score tiles */
body.deuce-active .scoreCard{
  animation: none !important;
}
@keyframes deuceTileGlow{
  from { box-shadow: 0 18px 40px rgba(0,0,0,.45), 0 0 18px rgba(255,0,90,.55); }
  to   { box-shadow: 0 18px 40px rgba(0,0,0,.45), 0 0 46px rgba(255,0,90,1); }
}

@media (max-width: 430px){
  .deuceBadge{ font-size: 18px; padding: 10px 18px; letter-spacing: 4px; }
}

50%{ transform: scale(1.06); opacity:.86; }
    }

    /* Advantage badge */
    .advBadge{
      display:none !important; /* ADV badge hidden (glow used instead) */
      position:absolute;
      top: 12px;
      right: 12px;
      font-size: 10px;
      font-weight: 950;
      letter-spacing: 2px;
      padding: 5px 8px;
      border-radius: 999px;
      background: rgba(255,255,255,.10);
      border: 1px solid rgba(255,255,255,.14);
      color: rgba(255,255,255,.92);
      text-transform: uppercase;
      white-space:nowrap;
    }

    
    /* Advantage glow on main score (replaces ADV badge) */
    .advScore{
      /* advantage glow ONLY on the player who is +1 after deuce */
      text-shadow:
        0 0 10px rgba(0,255,180,.85),
        0 0 22px rgba(0,255,180,.75),
        0 0 44px rgba(0,255,180,.55),
        0 0 90px rgba(0,220,120,.80),
        0 0 140px rgba(0,220,120,.55);
      filter: brightness(1.35) saturate(1.25) drop-shadow(0 0 18px rgba(0,255,170,.70));
      animation: advPulse 0.75s ease-in-out infinite;
    }
    @keyframes advPulse{ 0%,100%{ transform: scale(1); } 50%{ transform: scale(1.08); } }
      50%{ transform: scale(1.05); }
    }
/* High-impact score change animation */
    .scoreBoom{
      /* Bounce up, then SLAM down on every point */
      animation: scoreBoom .62s cubic-bezier(.18,.95,.18,1) 0s 1;
      transform-origin: 50% 100%;
      will-change: transform, filter;
      text-shadow:
        0 0 10px rgba(255,255,255,.38),
        0 0 26px rgba(255,255,255,.22),
        0 0 54px rgba(47,123,255,.18);
    }
    @keyframes scoreBoom{
      0%   { transform: translateY(0)    scale(1);    filter: brightness(1); }
      18%  { transform: translateY(-24px) scale(1.14); filter: brightness(1.35); }
      36%  { transform: translateY(10px) scale(.92);  filter: brightness(1.18); }
      52%  { transform: translateY(-12px) scale(1.06); filter: brightness(1.24); }
      70%  { transform: translateY(5px)  scale(.98);  filter: brightness(1.12); }
      100% { transform: translateY(0)    scale(1);    filter: brightness(1); }
    }
    .cardGlow{
      animation: cardGlow .55s ease-out 0s 1;
    }
    @keyframes cardGlow{
      0%{ box-shadow: 0 18px 40px rgba(0,0,0,.45); }
      40%{ box-shadow: 0 18px 40px rgba(0,0,0,.45), 0 0 0 8px rgba(255,255,255,.06), 0 0 40px rgba(0,255,157,.18); }
      100%{ box-shadow: 0 18px 40px rgba(0,0,0,.45); }
    }

    /* Game winner popup */
    .gamePopupWrap{
      position: fixed;
      inset: 0;
      display:none;
      align-items:center;
      justify-content:center;
      z-index: 1200;
      pointer-events:none;
    }
    .gamePopupWrap.show{ display:flex; }
    .gamePopupWrap.show::before{
      content:"";
      position:absolute;
      inset:0;
      background: rgba(0,0,0,.45);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      animation: overlayIn .18s ease-out forwards;
    }
    @keyframes overlayIn{
      from{ opacity:0; }
      to{ opacity:1; }
    }
    .gamePopup{
      position: relative;
      width: min(620px, calc(100vw - 34px));
      border-radius: 26px;
      border: 1px solid rgba(255,255,255,.22);
      background: rgba(0,0,0,.62);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      box-shadow: 0 34px 120px rgba(0,0,0,.70);
      padding: 28px 22px 24px;
      transform: translateY(10px) scale(.94);
      opacity: 0;
      animation: popupBigIn .28s cubic-bezier(.2,.9,.2,1) forwards;
      z-index: 1;
    }
    .gamePopup::after{
      content:"";
      position:absolute;
      inset:-14px;
      border-radius: 34px;
      border: 2px solid rgba(255,154,60,.45);
      box-shadow: 0 0 26px rgba(255,154,60,.35);
      animation: celebrateRing 1.1s ease-out infinite;
      pointer-events:none;
    }
    @keyframes popupBigIn{
      to{ transform: translateY(0) scale(1); opacity:1; }
    }
    @keyframes celebrateRing{
      0%{ opacity:.9; transform: scale(.98); }
      60%{ opacity:.25; transform: scale(1.06); }
      100%{ opacity:0; transform: scale(1.12); }
    }
    .gamePopup h3{
      margin:0;
      font-size: 24px;
      font-weight: 950;
      letter-spacing: 2px;
      text-transform: uppercase;
      color: rgba(255,255,255,.95);
      text-align:center;
    }
    .gamePopup .subline{
      margin-top: 12px;
      text-align:center;
      font-size: 16px;
      font-weight: 900;
      letter-spacing: 2px;
      color: rgba(255,255,255,.78);
      text-transform: uppercase;
    }
    @media (max-width: 430px){
      .gamePopup{ padding: 24px 18px 20px; }
      .gamePopup h3{ font-size: 20px; }
      .gamePopup .subline{ font-size: 14px; }
    }



    /* ============================
       Flashy celebration popups
       ============================ */

    /* Make GAME WON popup feel like a celebration */
    .gamePopupWrap.show .gamePopup{
      animation: popupBigIn .22s cubic-bezier(.15,.95,.15,1) forwards, popJiggle .55s ease-in-out .10s 1;
    }
    @keyframes popJiggle{
      0%{ transform: translateY(0) scale(1); }
      25%{ transform: translateY(-2px) scale(1.02); }
      55%{ transform: translateY(0) scale(.99); }
      85%{ transform: translateY(-1px) scale(1.01); }
      100%{ transform: translateY(0) scale(1); }
    }
    .gamePopup{
      background: radial-gradient(900px 360px at 20% 0%, rgba(47,123,255,.28), transparent 55%),
                  radial-gradient(900px 360px at 80% 0%, rgba(255,154,60,.22), transparent 58%),
                  rgba(0,0,0,.66);
    }
    .gamePopup::before{
      content:"";
      position:absolute;
      inset:-2px;
      border-radius: 28px;
      background: linear-gradient(90deg, rgba(31,99,255,.55), rgba(255,154,60,.55));
      opacity:.35;
      filter: blur(18px);
      animation: glowSweep 1.05s linear infinite;
      pointer-events:none;
    }
    @keyframes glowSweep{
      0%{ transform: translateX(-18px); opacity:.28; }
      50%{ transform: translateX(18px); opacity:.50; }
      100%{ transform: translateX(-18px); opacity:.28; }
    }

    /* Confetti-ish sparkles (pure CSS) */
    .gamePopup .subline{
      position:relative;
    }
    .gamePopup .subline::after{
      content:"";
      position:absolute;
      left:50%;
      top: -18px;
      width: 220px;
      height: 44px;
      transform: translateX(-50%);
      background:
        radial-gradient(circle at 10% 60%, rgba(255,255,255,.85) 0 2px, transparent 3px),
        radial-gradient(circle at 25% 20%, rgba(255,154,60,.95) 0 3px, transparent 4px),
        radial-gradient(circle at 45% 70%, rgba(31,99,255,.95) 0 3px, transparent 4px),
        radial-gradient(circle at 65% 25%, rgba(255,255,255,.85) 0 2px, transparent 3px),
        radial-gradient(circle at 82% 65%, rgba(255,154,60,.95) 0 3px, transparent 4px),
        radial-gradient(circle at 92% 30%, rgba(31,99,255,.95) 0 3px, transparent 4px);
      opacity:.0;
      animation: sparkBurst .85s ease-out .12s 1;
      pointer-events:none;
    }
    @keyframes sparkBurst{
      0%{ opacity:0; transform: translateX(-50%) scale(.85); filter: blur(0px); }
      20%{ opacity:1; transform: translateX(-50%) scale(1.0); }
      100%{ opacity:0; transform: translateX(-50%) scale(1.25); filter: blur(1px); }
    }

    /* MATCH WON mega-popup */
    .matchPopupWrap{
      position: fixed;
      inset: 0;
      display:none;
      align-items:center;
      justify-content:center;
      z-index: 1300;
      pointer-events:none;
    }
    .matchPopupWrap.show{ display:flex; }
    .matchPopupWrap.show::before{
      content:"";
      position:absolute;
      inset:0;
      background: rgba(0,0,0,.52);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      animation: overlayIn .18s ease-out forwards;
    }
    .matchPopup{
      position:relative;
      width: min(720px, calc(100vw - 34px));
      border-radius: 30px;
      border: 1px solid rgba(255,255,255,.24);
      background:
        radial-gradient(1100px 420px at 10% 0%, rgba(255,210,90,.25), transparent 58%),
        radial-gradient(1100px 420px at 90% 10%, rgba(47,123,255,.22), transparent 60%),
        rgba(0,0,0,.70);
      box-shadow: 0 40px 160px rgba(0,0,0,.78);
      padding: 34px 24px 28px;
      transform: translateY(12px) scale(.92);
      opacity: 0;
      animation: matchIn .28s cubic-bezier(.15,.95,.15,1) forwards, matchPulse 1.05s ease-in-out .25s 2;
      z-index: 1;
      overflow:hidden;
    }
    .matchPopup::after{
      content:"";
      position:absolute;
      inset:-18px;
      border-radius: 40px;
      border: 2px solid rgba(255,210,90,.55);
      box-shadow: 0 0 36px rgba(255,210,90,.35);
      animation: celebrateRing 1.0s ease-out infinite;
      pointer-events:none;
    }
    @keyframes matchIn{
      to{ transform: translateY(0) scale(1); opacity:1; }
    }
    @keyframes matchPulse{
      0%{ filter: brightness(1); }
      50%{ filter: brightness(1.22); }
      100%{ filter: brightness(1); }
    }
    .matchCrown{
      text-align:center;
      font-size: 42px;
      line-height: 1;
      filter: drop-shadow(0 0 20px rgba(255,210,90,.55));
      animation: crownPop .55s ease-out .08s 1;
    }
    @keyframes crownPop{
      0%{ transform: translateY(8px) scale(.8) rotate(-8deg); opacity:0; }
      60%{ transform: translateY(0) scale(1.08) rotate(6deg); opacity:1; }
      100%{ transform: translateY(0) scale(1) rotate(0deg); opacity:1; }
    }
    .matchPopup h3{
      margin: 10px 0 0;
      font-size: 28px;
      font-weight: 1000;
      letter-spacing: 4px;
      text-transform: uppercase;
      color: rgba(255,255,255,.98);
      text-align:center;
    }
    .matchPopup .subline{
      margin-top: 14px;
      text-align:center;
      font-size: 17px;
      font-weight: 950;
      letter-spacing: 2px;
      color: rgba(255,255,255,.82);
      text-transform: uppercase;
    }
    .matchSpark{
      position:absolute;
      inset:0;
      background:
        radial-gradient(circle at 20% 30%, rgba(255,210,90,.35) 0 2px, transparent 3px),
        radial-gradient(circle at 60% 20%, rgba(255,255,255,.25) 0 2px, transparent 3px),
        radial-gradient(circle at 80% 45%, rgba(47,123,255,.25) 0 2px, transparent 3px),
        radial-gradient(circle at 30% 75%, rgba(255,154,60,.22) 0 2px, transparent 3px),
        radial-gradient(circle at 70% 78%, rgba(255,255,255,.22) 0 2px, transparent 3px);
      opacity: 0;
      animation: matchSparkle 1.2s ease-out .1s 2;
      pointer-events:none;
    }
    @keyframes matchSparkle{
      0%{ opacity:0; transform: scale(.98); }
      25%{ opacity:1; transform: scale(1); }
      100%{ opacity:0; transform: scale(1.04); }
    }
    @media (max-width: 430px){
      .matchPopup{ padding: 28px 18px 22px; }
      .matchPopup h3{ font-size: 22px; letter-spacing: 3px; }
      .matchPopup .subline{ font-size: 14px; }
      .matchCrown{ font-size: 36px; }
    }

</style>

<style>
/* Stadium-level score hit: bounce + slam + impact flash */
@keyframes scoreBounceSlam {
  0%   { transform: translateY(0) scale(1);    filter: drop-shadow(0 0 0 rgba(255,255,255,0)); text-shadow: none; }
  12%  { transform: translateY(-18px) scale(1.38); filter: drop-shadow(0 10px 18px rgba(0,0,0,0.25)); }
  26%  { transform: translateY(-10px) scale(1.28); }
  40%  { transform: translateY(8px)  scale(0.98);  }
  52%  { transform: translateY(-6px) scale(1.10);  }
  64%  { transform: translateY(4px)  scale(1.02);  }
  76%  { transform: translateY(-2px) scale(1.04);  }
  88%  { transform: translateY(1px)  scale(1.01);  }
  100% { transform: translateY(0) scale(1); filter: drop-shadow(0 0 0 rgba(255,255,255,0)); text-shadow: none; }
}

@keyframes scoreImpactFlash {
  0%   { filter: drop-shadow(0 0 0 rgba(255,255,255,0)); text-shadow: 0 0 0 rgba(255,255,255,0); }
  35%  { filter: drop-shadow(0 0 22px rgba(255,255,255,0.85)); text-shadow: 0 0 20px rgba(255,255,255,0.9), 0 0 40px rgba(255,255,255,0.45); }
  100% { filter: drop-shadow(0 0 0 rgba(255,255,255,0)); text-shadow: 0 0 0 rgba(255,255,255,0); }
}

.score-animate {
  animation: scoreBounceSlam 0.55s cubic-bezier(.14,.86,.19,1.12);
  will-change: transform, filter;
  transform-origin: center;
}

.score-impact {
  animation: scoreImpactFlash 0.28s ease-out;
  will-change: filter, text-shadow;
}
</style>

<style>
/* ============================
   Celebration upgrades (Game + Match sounds & match popup shine)
   ============================ */

/* Make MATCH WON popup slightly bigger + shinier (no functional changes) */
.matchPopup{
  width: min(780px, calc(100vw - 28px));
  padding: 42px 28px 34px;
  border: 1px solid rgba(255,255,255,.30);
  box-shadow:
    0 46px 190px rgba(0,0,0,.80),
    0 0 0 1px rgba(255,210,90,.10) inset,
    0 0 60px rgba(255,210,90,.18),
    0 0 90px rgba(47,123,255,.10);
}

.matchPopup::before{
  content:"";
  position:absolute;
  inset:-3px;
  border-radius: 34px;
  background:
    radial-gradient(600px 220px at 20% 10%, rgba(255,255,255,.22), transparent 62%),
    radial-gradient(700px 260px at 80% 0%, rgba(255,210,90,.22), transparent 62%),
    linear-gradient(90deg, rgba(255,255,255,0), rgba(255,255,255,.14), rgba(255,255,255,0));
  opacity: .55;
  filter: blur(16px);
  animation: matchShineSweep 1.15s ease-in-out infinite;
  pointer-events:none;
}

@keyframes matchShineSweep{
  0%   { transform: translateX(-24px); opacity:.35; }
  45%  { transform: translateX(18px);  opacity:.70; }
  100% { transform: translateX(34px);  opacity:.40; }
}

.matchCrown{
  font-size: 60px;
  filter: drop-shadow(0 12px 26px rgba(0,0,0,.45)) drop-shadow(0 0 26px rgba(255,210,90,.22));
  animation: crownPop 0.48s cubic-bezier(.12,.98,.18,1.12) both, crownFloat 1.25s ease-in-out .48s infinite;
}

@keyframes crownPop{
  0%   { transform: translateY(10px) scale(.75) rotate(-6deg); opacity:0; }
  70%  { transform: translateY(-2px) scale(1.08) rotate(3deg); opacity:1; }
  100% { transform: translateY(0) scale(1) rotate(0deg); opacity:1; }
}

@keyframes crownFloat{
  0%,100% { transform: translateY(0); }
  50%     { transform: translateY(-4px); }
}

.matchPopup h3{
  font-size: 34px;
  letter-spacing: 2.6px;
}

@media (max-width: 430px){
  .matchPopup{ padding: 34px 20px 28px; }
  .matchCrown{ font-size: 54px; }
  .matchPopup h3{ font-size: 28px; }
}
</style>
<style>
/* Connected list modal (names of watchers/scorer) */
.connModalWrap{
  position: fixed;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 2000;
}
.connModalWrap.show{ display:flex; }
.connModalWrap::before{
  content:"";
  position:absolute;
  inset:0;
  background: rgba(0,0,0,.55);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
}
.connModal{
  position: relative;
  width: min(560px, calc(100vw - 28px));
  border-radius: 24px;
  border: 1px solid rgba(255,255,255,.18);
  background: rgba(0,0,0,.62);
  box-shadow: 0 36px 140px rgba(0,0,0,.75);
  padding: 18px 18px 14px;
  transform: translateY(10px) scale(.98);
  opacity: 0;
  animation: connModalIn .18s ease-out forwards;
}
@keyframes connModalIn{
  to { transform: translateY(0) scale(1); opacity: 1; }
}
.connModalHeader{
  display:flex;
  align-items:flex-start;
  justify-content:space-between;
  gap: 12px;
  margin-bottom: 10px;
}
.connModalTitle{
  margin:0;
  font-size: 18px;
  font-weight: 950;
  letter-spacing: .4px;
}
.connModalSub{
  margin:4px 0 0;
  font-size: 12.5px;
  color: rgba(255,255,255,.70);
  line-height: 1.25;
}
.connClose{
  border: 1px solid rgba(255,255,255,.14);
  background: rgba(255,255,255,.06);
  color: rgba(255,255,255,.92);
  border-radius: 14px;
  padding: 10px 12px;
  font-weight: 900;
  cursor: pointer;
  -webkit-tap-highlight-color: transparent;
}
.connList{
  margin-top: 10px;
  display:flex;
  flex-direction:column;
  gap: 10px;
  max-height: min(46vh, 420px);
  overflow:auto;
  padding-right: 4px;
}
.connItem{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap: 10px;
  padding: 12px 12px;
  border-radius: 18px;
  border: 1px solid rgba(255,255,255,.12);
  background: rgba(255,255,255,.05);
}
.connName{
  font-weight: 950;
  letter-spacing: .3px;
  overflow:hidden;
  text-overflow:ellipsis;
  white-space:nowrap;
}
.connRole{
  font-size: 12px;
  font-weight: 900;
  letter-spacing: 2px;
  text-transform: uppercase;
  padding: 6px 10px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,.12);
  background: rgba(0,0,0,.22);
  color: rgba(255,255,255,.78);
  white-space:nowrap;
}
.connEmpty{
  padding: 12px 12px;
  border-radius: 18px;
  border: 1px dashed rgba(255,255,255,.18);
  background: rgba(255,255,255,.04);
  color: rgba(255,255,255,.74);
  font-weight: 800;
}
</style>
<style>
/* ============================
   Timeout Feature (Additive)
   ============================ */
.timeoutRow{
  display:flex;
  gap: 10px;
  margin-top: 10px;
  justify-content: center;
  flex-wrap: wrap;
}
.timeoutBtn{
  border: 1px solid rgba(255,255,255,.14);
  background: rgba(255,255,255,.07);
  color: rgba(255,255,255,.92);
  border-radius: 16px;
  padding: 10px 12px;
  font-weight: 950;
  letter-spacing: .4px;
  cursor: pointer;
  -webkit-tap-highlight-color: transparent;
}
.timeoutBtn.blue{ background: rgba(56, 122, 255, .18); }
.timeoutBtn.orange{ background: rgba(255, 144, 56, .18); }

.timeoutBtn:disabled{
  cursor: not-allowed;
  opacity: .45;
  filter: grayscale(1);
}

/* Timeout popup */
.timeoutPopupWrap{
  position: fixed;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 2500;
}
.timeoutPopupWrap.show{ display:flex; }
.timeoutPopupWrap::before{
  content:"";
  position:absolute;
  inset:0;
  background: rgba(0,0,0,.62);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
}
.timeoutPopup{
  position: relative;
  width: min(780px, calc(100vw - 28px));
  padding: 42px 28px 34px;
  border-radius: 34px;
  border: 1px solid rgba(255,255,255,.24);
  background: rgba(0,0,0,.62);
  box-shadow:
    0 46px 190px rgba(0,0,0,.80),
    0 0 0 1px rgba(255,255,255,.12) inset,
    0 0 70px rgba(255,255,255,.12);
  text-align: center;
  transform: translateY(10px) scale(.98);
  opacity: 0;
  animation: timeoutIn .18s ease-out forwards;
}
@keyframes timeoutIn{
  to { transform: translateY(0) scale(1); opacity: 1; }
}
.timeoutPopup::before{
  content:"";
  position:absolute;
  inset:-3px;
  border-radius: 34px;
  background:
    radial-gradient(700px 280px at 20% 0%, rgba(255,255,255,.18), transparent 62%),
    radial-gradient(700px 280px at 80% 0%, rgba(255,210,90,.18), transparent 62%),
    linear-gradient(90deg, rgba(255,255,255,0), rgba(255,255,255,.14), rgba(255,255,255,0));
  opacity: .50;
  filter: blur(16px);
  animation: timeoutShine 1.2s ease-in-out infinite;
  pointer-events:none;
}
@keyframes timeoutShine{
  0%   { transform: translateX(-24px); opacity:.30; }
  45%  { transform: translateX(18px);  opacity:.65; }
  100% { transform: translateX(34px);  opacity:.38; }
}
.timeoutTitle{
  margin: 0 0 12px;
  font-size: 34px;
  font-weight: 1000;
  letter-spacing: 2.4px;
  text-transform: uppercase;
}
.timeoutSub{
  margin: 0 0 14px;
  font-size: 14px;
  color: rgba(255,255,255,.75);
  font-weight: 800;
}
.timeoutTimer{
  font-size: 64px;
  font-weight: 1000;
  letter-spacing: 2px;
  margin-top: 8px;
  text-shadow: 0 0 28px rgba(255,255,255,.22);
}
.timeoutTimer.warn{
  animation: timeoutWarnPulse .55s ease-in-out infinite;
}
@keyframes timeoutWarnPulse{
  0%,100% { transform: scale(1); }
  50%     { transform: scale(1.05); }
}

/* T indicator on score boxes */
.scoreCard{ position: relative; }

.scoreBox{
  position: relative;
}
.timeoutTag{
  position:absolute;
  right: 10px;
  bottom: 8px;
  font-weight: 1000;
  font-size: 14px;
  letter-spacing: 2px;
  padding: 5px 8px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,.22);
  background: rgba(0,0,0,.25);
  color: rgba(255,255,255,.90);
  box-shadow: 0 0 16px rgba(255,255,255,.10);
  display:none;
}
.timeoutTag.show{ display:block; }

@media (max-width: 430px){
  .timeoutPopup{ padding: 34px 20px 28px; }
  .timeoutTitle{ font-size: 28px; }
  .timeoutTimer{ font-size: 56px; }
}
</style>
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <div class="brand">
        <span class="dot"></span>
        <span>Table Tennis For Life ‚Äî Live Score Card</span>
      </div>
      <div class="pill" id="statusPill"><span class="statusDot" id="statusDot"></span><span id="statusText">Starting...</span></div>
    </div>

    <div class="grid">
      <!-- LEFT: main -->
      <div class="panel" id="mainPanel">
        <div class="panelHeader">
          <div>
            <h2 id="leftTitle">Setup</h2>
            <p class="sub" id="leftSub">Name players, choose who starts, then Start match</p>
          </div>
          <div class="pill"><span>Role:</span> <b id="roleBadge">...</b></div>
        </div>

        <div class="panelBody" id="leftBody">
          <!-- Setup view -->
          <div id="setupView">
            <div class="hint">
              This page is designed for iPhone scoring + live watching. Share the <strong>same room URL</strong> with watchers.
              <div class="stateLine">
                <span class="stateBadge idle" id="roomStateBadge"><span class="miniDot"></span><span id="roomStateText">Room: idle</span></span>
                <span style="color:var(--muted);font-size:12px;" id="roomStateMsg"></span>
              </div>
              <div style="margin-top:10px;">
                <strong>Tip:</strong> Use different rooms for parallel matches, like <code>?room=table1</code> and <code>?room=table2</code>.
              </div>
            </div>

            <div class="form">
              <div class="field">
                <label>First player (Blue)</label>
                <input id="nameA" placeholder="First player" maxlength="22" />
              </div>
              <div class="field">
                <label>Second player (Orange)</label>
                <input id="nameB" placeholder="Second player" maxlength="22" />
              </div>

              <div class="field">
                <label>Who starts? (Toss winner)</label>
                <select id="tossWinner">
                  <option value="A">First player</option>
                  <option value="B">Second player</option>
                </select>
              </div>
              <div class="field">
                <label>Best of</label>
                <select id="bestOf">
                  <option value="5" selected>5</option>
                  <option value="7">7</option>
                </select>
              </div>

              <div class="field">
                <label>Points to win</label>
                <input id="pointsToWin" type="number" min="1" max="99" value="11" />
              </div>
              <div class="field">
                <label>Scorer PIN (only scorer needs)</label>
                <input id="pin" type="password" inputmode="numeric" maxlength="8" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢" />
              </div>

              <div class="field full btnRow">
                <button class="btn primary" id="startBtn">‚ñ∂ Start match</button>
                <button class="btn secondary" id="watchBtn">üëÅ Watch live</button>
              </div>
            </div>

            <div class="smallNote">Watchers do not need a PIN. Only the scorer can start and update the match.</div>
          </div>

          <!-- Live view -->
          <div id="liveView" style="display:none;">
            <div class="scoreTop">
              <div>
                <p class="matchTitle" id="matchTitle">Live</p>
                <p class="matchMeta" id="matchMeta">Game 1 ‚Ä¢ Best of 5</p>
              </div>
              <div class="pill" id="roomPill"><span>Room:</span> <b id="roomText"></b></div>
            </div>

            <div class="scoreGrid" id="scoreArea">
              <div class="scoreCard blue">
                <div class="timeoutTag" id="timeoutTagA">T</div>
                <div class="nameRow">
                  <div class="nameLeft"><p class="pname" id="liveNameA">Player A</p><span class="advBadge" id="advA" style="display:none;">ADV</span></div>
                  <span class="serve" id="serveA" style="display:none;" aria-label="Server"></span>
                </div>
                <div class="bigScore" id="scoreA">0</div>
              </div>

              <div class="midIcon">‚Ü∫</div>

              <div class="scoreCard orange">
                <div class="timeoutTag" id="timeoutTagB">T</div>
                <div class="nameRow">
                  <div class="nameLeft"><p class="pname" id="liveNameB">Player B</p><span class="advBadge" id="advB" style="display:none;">ADV</span></div>
                  <span class="serve" id="serveB" style="display:none;" aria-label="Server"></span>
                </div>
                <div class="bigScore" id="scoreB">0</div>
              </div>
            
            <!-- Match score + deuce -->
            <div class="matchBar" id="matchBar">
              <!-- <div class="metaPill" id="bestOfPill">BEST OF 5</div>-->
              <div class="metaPill matchPill" id="matchPill"><span class="mlabel">MATCH</span><span id="matchSetsA">0</span><span class="mdash">‚Äì</span><span id="matchSetsB">0</span></div>
            </div>

            <div class="deuceRow" id="deuceRow" style="display:none;">
              <div class="deuceBadge" id="deuceBadge">DEUCE</div>
            </div>

</div>

            <div class="setsRow">
              <div class="setsCol">
                <div class="setsLabel">Games (history)</div>
                <div class="setList" id="setList"></div>
              </div>
            </div>

            <div class="controls" id="scorerControls" style="display:none;">
              <button class="cbtn blue" id="timeoutBlueBtn" type="button" onclick="window.startTimeout && window.startTimeout('A')">Timeout (Blue)</button>
              <button class="cbtn orange" id="timeoutOrangeBtn" type="button" onclick="window.startTimeout && window.startTimeout('B')">Timeout (Orange)</button>
<button class="cbtn blue" id="ptA">+1 (Blue)</button>
              <button class="cbtn orange" id="ptB">+1 (Orange)</button>
              <button class="cbtn neutral" id="undoBtn">Undo</button>
              <button class="cbtn neutral" id="swapServeBtn">Swap Serve</button>
              <button class="cbtn warn" id="cancelMatchBtn">Cancel</button>
              <button class="cbtn warn" id="endMatchBtn">End Match</button>
              <button class="cbtn good" id="restartMatchBtn">Restart</button>
              <button class="cbtn good" id="newMatchBtn">New Match</button>
            </div>

            <div class="footerNote" id="liveFooter">TTFL Live ‚Ä¢ Single scorer ‚Ä¢ Unlimited watchers</div>
          </div>

          <!-- Result view -->
          <div id="resultView" style="display:none;">
            <div class="doneTop">
              <span>Done</span>
              <button class="cbtn good" id="downloadBtn" style="max-width:220px;">Download Scorecard</button>
            </div>
            <div class="resultTitle">Result</div>
            <div class="resultScore">
              <div class="resultSide">
                <div class="resultName" id="finalNameA">Player A</div>
                <div class="badge blue" id="finalSetsA">0</div>
              </div>
              <div style="opacity:.7;">:</div>
              <div class="resultSide">
                <div class="resultName" id="finalNameB">Player B</div>
                <div class="badge orange" id="finalSetsB">0</div>
              </div>
            </div>
            <div class="totalTime" id="totalTime">Total time: 00:00:00</div>

            <div class="setsRow">
              <div class="setsCol">
                <div class="setsLabel">Sets</div>
                <div class="setList" id="finalSetList"></div>
              </div>
            </div>

            <div class="controls" id="resultControls">
              <button class="cbtn good" id="resultNewMatchBtn">Start New Match</button>
              <button class="cbtn neutral" id="backToSetupBtn">Back to Setup</button>
            </div>

            <div class="footerNote">Tip: Add this page to Home Screen for quick scoring tomorrow.</div>
          </div>
        </div>
      </div>

      <!-- RIGHT: connection -->
      <div class="panel">
        <div class="panelHeader">
          <div>
            <h2>Connection</h2>
            <p class="sub">Saved in this browser</p>
          </div>
          <div class="pill"><span>Mode:</span> <b id="modeText">...</b></div>
        </div>
        <div class="panelBody">
          <div class="hint" style="margin-bottom:12px;">
            <strong>Scorer link</strong> owns the room. If a second scorer opens the same room, they will be forced into watch mode.
            <br><br>
            Use different rooms for parallel matches: <code>room=table1</code>, <code>room=table2</code>, etc.
          </div>

          <div class="form" style="grid-template-columns:1fr;">
            <div class="field">
              <label>Room</label>
              <input id="roomInput" placeholder="table1" />
            </div>
            <div class="field">
              <label>Share (watch)</label>
              <input id="shareWatch" readonly />
            </div>
            <div class="field">
              <label>Share (scorer)</label>
              <input id="shareScorer" readonly />
            </div>
            <div class="btnRow" style="grid-template-columns:1fr;">
              <button class="btn secondary" id="copyWatch">Copy Watch Link</button>
              <button class="btn secondary" id="copyScorer">Copy Scorer Link</button>
            </div>
          </div>

          <div class="smallNote" id="connNote">If you see ‚ÄúPermission denied‚Äù, fix Rules and Anonymous Auth.</div>
        </div>
      </div>
    </div>
  </div>

  <div class="toast" id="toast"></div>


  <div class="connModalWrap" id="connModalWrap" aria-live="polite" aria-atomic="true">
    <div class="connModal" role="dialog" aria-modal="true" aria-label="Connected">
      <div class="connModalHeader">
        <div>
          <h3 class="connModalTitle" id="connModalTitle">Connected</h3>
          <p class="connModalSub" id="connModalSub">Tap outside to close.</p>
        </div>
        <button class="connClose" id="connCloseBtn">Close</button>
      </div>
      <div class="connList" id="connList"></div>
    </div>
  </div>

  <div class="gamePopupWrap" id="gamePopupWrap" aria-live="polite" aria-atomic="true">
    <div class="gamePopup" id="gamePopup">
      <h3 id="gamePopupTitle">PLAYER WINS GAME</h3>
      <div class="subline" id="gamePopupSub">Match Score: 0 ‚Äì 0</div>
    </div>
</div>

<div class="matchPopupWrap" id="matchPopupWrap" aria-live="polite" aria-atomic="true">
    <div class="matchPopup" id="matchPopup">
      <div class="matchCrown" aria-hidden="true">üèÜ</div>
      <h3 id="matchPopupTitle">MATCH WON</h3>
      <div class="subline" id="matchPopupSub">Final Score: 0 ‚Äì 0</div>
      <div class="matchSpark" aria-hidden="true"></div>
    </div>
  </div>

<!-- html2canvas for download -->
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

  <script type="module">
    /*******
     * 0) URL + params
     *******/
    const pageUrl = new window.URL(window.location.href);
    const qp = pageUrl.searchParams;

    const roleParam = (qp.get("role") || "watch").toLowerCase();   // watch | scorer
    const roomParam = (qp.get("room") || localStorage.getItem("ttfl_room") || "table1").trim();
    
    // Display name (used for presence list)
    const NAME_MAX = 22;
    const _roleKey = (roleParam === "scorer") ? "scorer" : "watch";
    const _nameKey = `ttfl_name_${roomParam.toLowerCase()}_${_roleKey}`;
    let displayName = (localStorage.getItem(_nameKey) || "").trim();
    function sanitizeName(n){
      const t = (n || "").trim().replace(/\s+/g," ");
      return t.slice(0, NAME_MAX);
    }
    function ensureDisplayName(){
      if (displayName) return displayName;
      const promptLabel = (_roleKey === "scorer") ? "Enter your name (Scorer)" : "Enter your name (Watcher)";
      const entered = sanitizeName(window.prompt(promptLabel, "") || "");
      displayName = entered || ((_roleKey === "scorer") ? "Scorer" : "Watcher");
      localStorage.setItem(_nameKey, displayName);
      return displayName;
    }

    // If the browser blocks prompt during async auth, ask on first user gesture instead.
    function ensureNameOnFirstGesture(){
      try{
        if (!displayName) ensureDisplayName();
      }catch(e){}
    }
    ["pointerdown","touchstart","mousedown","keydown"].forEach(evt => {
      window.addEventListener(evt, ensureNameOnFirstGesture, { once: true, passive: true });
    });



    /*******
     * 1) UI helpers
     *******/
    const $ = (id) => document.getElementById(id);
    const toastEl = $("toast");

    
function toast(msg, sub = "") {
  toastEl.innerHTML = `${msg}${sub ? `<small>${sub}</small>` : ""}`;
  toastEl.classList.add("show");
  setTimeout(() => toastEl.classList.remove("show"), 2600);
}

// Game winner popup (premium)
const gamePopupWrap = $("gamePopupWrap");
const gamePopupTitle = $("gamePopupTitle");
const gamePopupSub = $("gamePopupSub");
let popupTimer = null;

const matchPopupWrap = $("matchPopupWrap");
const matchPopupTitle = $("matchPopupTitle");
const matchPopupSub = $("matchPopupSub");
let matchPopupTimer = null;

function _restartOverlay(el){
  if (!el) return;
  el.classList.remove("show");
  // force reflow so animations always restart
  void el.offsetWidth;
  el.classList.add("show");
}


/* ============================
   Celebration sounds (Web Audio, no external files)
   - Plays after first user interaction (mobile-friendly).
   ============================ */
const TTFL_AUDIO = (() => {
  let ctx = null;
  let unlocked = false;

  function ensureCtx(){
    if (ctx) return ctx;
    ctx = new (window.AudioContext || window.webkitAudioContext)();
    return ctx;
  }

  function unlock(){
    if (unlocked) return;
    try{
      const c = ensureCtx();
      if (c.state === "suspended") c.resume().catch(()=>{});
      unlocked = true;
    } catch(e){
      unlocked = false;
    }
  }

  ["pointerdown","touchstart","mousedown","keydown"].forEach(evt => {
    window.addEventListener(evt, unlock, { once: true, passive: true });
  });

  function tone(freq, t, dur, type="sine", gain=0.18){
    const c = ensureCtx();
    const o = c.createOscillator();
    const g = c.createGain();
    o.type = type;
    o.frequency.setValueAtTime(freq, t);
    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(gain, t + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
    o.connect(g); g.connect(c.destination);
    o.start(t); o.stop(t + dur + 0.02);
  }

  function noiseBurst(t, dur=0.12, gain=0.12){
    const c = ensureCtx();
    const bufferSize = Math.floor(c.sampleRate * dur);
    const buffer = c.createBuffer(1, bufferSize, c.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i=0;i<bufferSize;i++){
      // slightly decaying noise
      const k = 1 - (i / bufferSize);
      data[i] = (Math.random()*2-1) * (k*k);
    }
    const src = c.createBufferSource();
    src.buffer = buffer;
    const g = c.createGain();
    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(gain, t + 0.005);
    g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
    src.connect(g); g.connect(c.destination);
    src.start(t); src.stop(t + dur + 0.02);
  }

  function playGameWin(){
    if (!unlocked) return;
    const c = ensureCtx();
    const t = c.currentTime + 0.01;
    // quick celebratory triad + sparkle noise
    tone(523.25, t + 0.00, 0.11, "triangle", 0.14); // C5
    tone(659.25, t + 0.04, 0.11, "triangle", 0.12); // E5
    tone(783.99, t + 0.08, 0.12, "triangle", 0.12); // G5
    noiseBurst(t + 0.03, 0.10, 0.07);
  }

  function playMatchWin(){
    if (!unlocked) return;
    const c = ensureCtx();
    const t = c.currentTime + 0.01;
    tone(392.00, t + 0.00, 0.14, "sawtooth", 0.10);
    tone(523.25, t + 0.06, 0.16, "sawtooth", 0.11);
    tone(659.25, t + 0.12, 0.18, "sawtooth", 0.11);
    tone(783.99, t + 0.18, 0.22, "sawtooth", 0.10);
    tone(110.00, t + 0.22, 0.10, "sine", 0.22);
    tone(55.00,  t + 0.22, 0.12, "sine", 0.16);
    noiseBurst(t + 0.20, 0.18, 0.10);
  }

  function playTimeoutStart(){
    if (!unlocked) return;
    const c = ensureCtx();
    const t = c.currentTime + 0.01;
    tone(880.00, t + 0.00, 0.18, "sine", 0.18);
    tone(659.25, t + 0.02, 0.20, "sine", 0.14);
    noiseBurst(t + 0.01, 0.10, 0.06);
  }

  function playTimeoutWarn5(){
    if (!unlocked) return;
    const c = ensureCtx();
    const t = c.currentTime + 0.01;
    [0,1,2,3,4].forEach(i => {
      tone(1046.50, t + i*0.18, 0.07, "triangle", 0.12);
    });
  }

  function playTimeoutTick(){
    if (!unlocked) return;
    const c = ensureCtx();
    const t = c.currentTime + 0.01;
    tone(880.00, t, 0.045, "sine", 0.07);
  }

  function playDeuce(){
    if (!unlocked) return;
    const c = ensureCtx();
    const t = c.currentTime + 0.01;

    // Dramatic DEUCE stinger
    tone(220.00, t + 0.00, 0.16, "sawtooth", 0.12);
    tone(329.63, t + 0.05, 0.18, "sawtooth", 0.12);
    tone(493.88, t + 0.10, 0.20, "sawtooth", 0.12);
    tone(1046.50, t + 0.18, 0.12, "triangle", 0.14);
    noiseBurst(t + 0.08, 0.18, 0.10);
  }

  return { playGameWin, playMatchWin, playDeuce, playTimeoutStart, playTimeoutWarn5, playTimeoutTick };
})();



function showGameWinPopup(winnerName, setsA, setsB){
  if (!gamePopupWrap) return;

  const name = (winnerName || "PLAYER").toUpperCase();
  gamePopupTitle.textContent = `GAME WON ‚Äì ${name}`;
  gamePopupSub.textContent = `Match Score: ${setsA} ‚Äì ${setsB}`;

  _restartOverlay(gamePopupWrap);

  try{ TTFL_AUDIO.playGameWin(); }catch(e){}
  if (popupTimer) clearTimeout(popupTimer);
  popupTimer = setTimeout(() => {
    gamePopupWrap.classList.remove("show");
  }, 3400); // 3‚Äì4 seconds
}

function showMatchWinPopup(winnerName, setsA, setsB){
  if (!matchPopupWrap) return;

  const name = (winnerName || "PLAYER").toUpperCase();
  matchPopupTitle.textContent = `MATCH WON ‚Äì ${name}`;
  matchPopupSub.textContent = `Final Score: ${setsA} ‚Äì ${setsB}`;

  _restartOverlay(matchPopupWrap);

  try{ TTFL_AUDIO.playMatchWin(); }catch(e){}
  if (matchPopupTimer) clearTimeout(matchPopupTimer);
  matchPopupTimer = setTimeout(() => {
    matchPopupWrap.classList.remove("show");
  }, 3800); // ~3‚Äì4 seconds
}


    function setStatus(text, kind="idle") {
      $("statusText").textContent = text;
      const dot = $("statusDot");
      const color = {
        idle: "rgba(255,255,255,.35)",
        ok: "var(--good)",
        warn: "rgba(255,255,255,.55)",
        bad: "var(--bad)"
      }[kind] || "rgba(255,255,255,.35)";
      dot.style.background = color;
    }

    function showView(view) {
      $("setupView").style.display = (view === "setup") ? "" : "none";
      $("liveView").style.display  = (view === "live")  ? "" : "none";
      $("resultView").style.display= (view === "result")? "" : "none";
      $("leftTitle").textContent = view === "setup" ? "Setup" : (view === "result" ? "Match Result" : "Live");
      $("leftSub").textContent = view === "setup"
        ? "Name players, choose who starts, then Start match"
        : (view === "result" ? "Final score saved in match history" : "Live score updates instantly for watchers");
    }

    function clampName(s, fallback) {
      const t = (s || "").trim();
      return t.length ? t.slice(0,22) : fallback;
    }


    function fmtDur(ms){
      const total = Math.max(0, Math.floor((Number(ms)||0)/1000));
      const h = String(Math.floor(total/3600)).padStart(2,'0');
      const m = String(Math.floor((total%3600)/60)).padStart(2,'0');
      const s = String(total%60).padStart(2,'0');
      return `${h}:${m}:${s}`;
    }


    function clone(obj){
      try { return structuredClone(obj); } catch { return JSON.parse(JSON.stringify(obj)); }
    }

    function setRoomStateBadge(state, msg=""){
      const badge = $("roomStateBadge");
      const text = $("roomStateText");
      const msgEl = $("roomStateMsg");

      badge.classList.remove("idle","scheduled","live","cancelled");
      badge.classList.add(state || "idle");

      const label = ({
        idle: "Room: idle",
        scheduled: "Room: scheduled",
        live: "Room: live",
        cancelled: "Room: cancelled"
      })[state] || "Room: idle";

      text.textContent = label;
      msgEl.textContent = msg || "";
    }

    /*******
     * 2) Firebase (Realtime Database)
     *******/
    const firebaseConfig = {
      apiKey: "AIzaSyD221i61Z824UbXSLRT-UZs7w60KNzh5nY",
      authDomain: "ttfl-live-score.firebaseapp.com",
      databaseURL: "https://ttfl-live-score-default-rtdb.firebaseio.com",
      projectId: "ttfl-live-score",
      storageBucket: "ttfl-live-score.firebasestorage.app",
      messagingSenderId: "698939580201",
      appId: "1:698939580201:web:80540510de083f676ce138"
    };

    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import { getDatabase, ref, get, set, update, onValue, off, serverTimestamp, runTransaction, onDisconnect, remove } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";

    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);
    const auth = getAuth(app);

    let uid = null;

    /*******
     * Presence (watchers count)
     *******/
    let presenceStarted = false;
    let presenceSnapshot = { watchers: [], scorers: [] };
    let presenceUnsub = null;

    function roleForPresence(){
      return (state.role === "scorer") ? "scorer" : "watch";
    }

    async function startPresence(){
      if (!uid || presenceStarted) return;
      presenceStarted = true;
      try{
        const myRef = ref(db, `rooms/${roomId}/presence/${uid}`);
        await set(myRef, { role: roleForPresence(), name: ensureDisplayName(), ts: serverTimestamp() });
        // auto-remove when tab closes / disconnects
        onDisconnect(myRef).remove();
        // keep timestamp fresh every 20s (helps in poor networks)
        setInterval(() => {
          try{ update(myRef, { role: roleForPresence(), name: ensureDisplayName(), ts: serverTimestamp() }); }catch(e){}
        }, 20000);
      }catch(e){
        console.error(e);
      }
    }

    function subscribePresence(){
      if (presenceUnsub) { presenceUnsub(); presenceUnsub = null; }
      const pRef = ref(db, `rooms/${roomId}/presence`);
      const handler = (snap) => {

const val = snap.val() || {};
        const watchers = [];
        const scorers = [];
        Object.values(val).forEach(v => {
          if (!v) return;
          const r = (v.role || "").toString().trim().toLowerCase();
          const nm = (v.name || "").toString().trim();
          const roleNorm = (r === "scorer") ? "scorer" : "watch"; // default to watcher if missing/unknown
          const safeName = nm ? nm.slice(0, 22) : (roleNorm === "scorer" ? "Scorer" : "Watcher");
          if (roleNorm === "watch") watchers.push(safeName);
          if (roleNorm === "scorer") scorers.push(safeName);
        });
// keep a snapshot for the modal
        presenceSnapshot = { watchers, scorers };

        // Real-time "Connected (N)" where N = active watchers
        $("statusText").textContent = `Connected (${watchers.length})`;
      };
      onValue(pRef, handler);
      presenceUnsub = () => off(pRef, "value", handler);
    }

    async function updatePresenceRole(){
      if (!uid) return;
      try{
        await update(ref(db, `rooms/${roomId}/presence/${uid}`), { role: roleForPresence(), name: ensureDisplayName(), ts: serverTimestamp() });
      }catch(e){}
    }


    /*******
     * 3) Data model
     *******/
    const roomId = roomParam.toLowerCase().replace(/[^a-z0-9_-]/g, "").slice(0,30) || "table1";
    localStorage.setItem("ttfl_room", roomId);

    const roomRef = ref(db, `rooms/${roomId}`);
    let currentMatchId = null;
    let currentMatchUnsub = null;
    let lastRoomSnapshot = null;

    const state = {
      role: roleParam === "scorer" ? "scorer" : "watch",
      match: null,
      undoStack: [],
      _prevScoreA: null,
      _prevScoreB: null,
      _prevSetsA: null,
      _prevSetsB: null,
      _prevGamesCount: null,
      _seenMatchOnce: false,
      _prevMatchStatus: null,
      _matchWinShown: false,
      timeoutUsedA: false,
      timeoutUsedB: false,
      _timeoutActive: false,
      _timeoutWarnPlayed: false,
      _timeoutTimerId: null,
      _timeoutEndsAt: null,
      _matchIdForTimeout: null,
    };

    /*******
     * 4) UI init
     *******/
    $("roleBadge").textContent = state.role;
    // Ask name once (used for presence list)
    ensureDisplayName();
    $("modeText").textContent = state.role;
    $("roomText").textContent = roomId;
    $("roomInput").value = roomId;

    // Links
    function buildLink(role, room) {
      const u = new window.URL(window.location.href);
      u.searchParams.set("role", role);
      u.searchParams.set("room", room);
      u.searchParams.set("v", "1");
      return u.origin + u.pathname + "?" + u.searchParams.toString();
    }
    function refreshShareLinks() {
      const room = ($("roomInput").value || "table1").trim().toLowerCase().replace(/[^a-z0-9_-]/g,"").slice(0,30) || "table1";
      $("shareWatch").value = buildLink("watch", room);
      $("shareScorer").value = buildLink("scorer", room);
    }
    refreshShareLinks();
    $("roomInput").addEventListener("input", refreshShareLinks);

    async function copyToClipboard(val) {
      try {
        await navigator.clipboard.writeText(val);
        toast("Copied");
      } catch {
        toast("Copy failed", "Tap and copy manually.");
      }
    }
    $("copyWatch").addEventListener("click", () => copyToClipboard($("shareWatch").value));
    $("copyScorer").addEventListener("click", () => copyToClipboard($("shareScorer").value));

    // Setup inputs
    function refreshTossOptions() {
      const a = clampName($("nameA").value, "First player");
      const b = clampName($("nameB").value, "Second player");
      const tw = $("tossWinner");
      const was = tw.value;
      tw.innerHTML = `
        <option value="A">${a}</option>
        <option value="B">${b}</option>
      `;
      tw.value = (was === "B") ? "B" : "A";
    }
    $("nameA").addEventListener("input", refreshTossOptions);
    $("nameB").addEventListener("input", refreshTossOptions);
    refreshTossOptions();

    $("watchBtn").addEventListener("click", () => {
      state.role = "watch";
      $("roleBadge").textContent = state.role;
    // Ask name once (used for presence list)
    ensureDisplayName();
      $("modeText").textContent = state.role;
      $("scorerControls").style.display = "none";
      updatePresenceRole();
      toast("Watch mode enabled");
      showView("live");
    });

    /*******
     * 5) Match logic helpers
     *******/
    function setsToWin(bestOf) {
      return Math.ceil(Number(bestOf) / 2);
    }

    function isGameWon(a, b, ptsToWin) {
      const win = Number(ptsToWin);
      if (a >= win || b >= win) {
        const diff = Math.abs(a - b);
        return diff >= 2;
      }
      return false;
    }

    function computeServer(match) {
      // Serve changes every 2 points; at deuce changes every 1.
      // IMPORTANT: We persist who starts each GAME via match.gameStartServer.
      const total = match.scoreA + match.scoreB;
      const deuce = (match.scoreA >= (match.pointsToWin - 1)) && (match.scoreB >= (match.pointsToWin - 1));
      const interval = deuce ? 1 : 2;

      const start = match.gameStartServer || match.tossWinner; // A or B
      const flips = Math.floor(total / interval);
      return (flips % 2 === 0) ? start : (start === "A" ? "B" : "A");
    }

    function renderLive(match) {
      if (!match) return;

      $("matchTitle").textContent = `${match.nameA} vs ${match.nameB}`;
      $("matchMeta").textContent = `Game ${match.gameIndex} ‚Ä¢ Best of ${match.bestOf}`;

      $("liveNameA").textContent = match.nameA;
      $("liveNameB").textContent = match.nameB;
      // Score numbers (with high-impact animation for watchers)
      const newA = Number(match.scoreA || 0);
      const newB = Number(match.scoreB || 0);
      $("scoreA").textContent = newA;
      $("scoreB").textContent = newB;

      // Animate score changes
      const scoreAEl = $("scoreA");
      const scoreBEl = $("scoreB");
      const cardA = scoreAEl.closest(".scoreCard");
      const cardB = scoreBEl.closest(".scoreCard");

      if (state._prevScoreA !== null && newA !== state._prevScoreA) {
        scoreAEl.classList.remove("scoreBoom");
        void scoreAEl.offsetWidth;
        scoreAEl.classList.add("scoreBoom");
        cardA && (cardA.classList.remove("cardGlow"), void cardA.offsetWidth, cardA.classList.add("cardGlow"));
      }
      if (state._prevScoreB !== null && newB !== state._prevScoreB) {
        scoreBEl.classList.remove("scoreBoom");
        void scoreBEl.offsetWidth;
        scoreBEl.classList.add("scoreBoom");
        cardB && (cardB.classList.remove("cardGlow"), void cardB.offsetWidth, cardB.classList.add("cardGlow"));
      }
      state._prevScoreA = newA;
      state._prevScoreB = newB;

      const srv = computeServer(match);
      $("serveA").style.display = srv === "A" ? "" : "none";
      $("serveB").style.display = srv === "B" ? "" : "none";

      // Deuce + advantage
      const isDeuce = (match.scoreA >= (match.pointsToWin - 1)) && (match.scoreB >= (match.pointsToWin - 1)) && (match.scoreA === match.scoreB);
      if (state._prevIsDeuce !== undefined && isDeuce && !state._prevIsDeuce) {
        try{ TTFL_AUDIO.playDeuce(); }catch(e){}
      }
      state._prevIsDeuce = isDeuce;
      const inDeucePhase = (match.scoreA >= (match.pointsToWin - 1)) && (match.scoreB >= (match.pointsToWin - 1));
      if (inDeucePhase) document.body.classList.add("deuce-active"); else document.body.classList.remove("deuce-active");
      $("deuceRow").style.display = isDeuce ? "" : "none";

      // Advantage is only meaningful in deuce phase when lead is exactly 1
      const diff = match.scoreA - match.scoreB;
      const advA = inDeucePhase && diff === 1;
      const advB = inDeucePhase && diff === -1;
      $("advA").style.display = "none";
      $("advB").style.display = "none";

      // Advantage glow (no ADV badge)
      const sElA = $("scoreA");
      const sElB = $("scoreB");
      if (advA) { sElA.classList.add("advScore"); } else { sElA.classList.remove("advScore"); }
      if (advB) { sElB.classList.add("advScore"); } else { sElB.classList.remove("advScore"); }

      // Match score (sets) below tiles
      // $("bestOfPill").textContent = `BEST OF ${match.bestOf}`;
      $("matchSetsA").textContent = match.setsA ?? 0;
      $("matchSetsB").textContent = match.setsB ?? 0;

      // Match score pulse when it changes
      const sA = Number(match.setsA ?? 0);
      const sB = Number(match.setsB ?? 0);
      if (state._prevSetsA !== null && (sA !== state._prevSetsA || sB !== state._prevSetsB)) {
        const pill = $("matchPill");
        pill.classList.remove("matchPulse");
        void pill.offsetWidth;
        pill.classList.add("matchPulse");
      }
      state._prevSetsA = sA;
      state._prevSetsB = sB;

      // Game-winner popup when a new completed game appears
      const gamesCount = (match.sets || []).length;
      if (state._prevGamesCount !== null && gamesCount > state._prevGamesCount) {
        const last = match.sets[gamesCount - 1];
        const winner = (last.a > last.b) ? (match.nameA || "PLAYER A") : (match.nameB || "PLAYER B");
        showGameWinPopup(winner, sA, sB);
      }
      state._prevGamesCount = gamesCount;

      const list = $("setList");
      list.innerHTML = "";
      (match.sets || []).forEach((s) => {
        const el = document.createElement("div");
        el.className = "setItem";
        el.innerHTML = `
          <div class="setScoreLeft">
            <span class="chipA">${s.a}</span>
            <span class="vsep">|</span>
            <span class="chipB">${s.b}</span>
          </div>
          <div class="setTimeRight">(${fmtDur(s.durationMs || 0)})</div>
        `;
        list.appendChild(el);
      });

      if (!match.sets || match.sets.length === 0) {
        const el = document.createElement("div");
        el.className = "setItem";
        el.style.opacity = ".65";
        el.textContent = "No games finished yet";
        list.appendChild(el);
      }
    }

    function renderResult(match) {

      // FINAL GUARANTEE: show MATCH WON popup for watchers whenever result renders for an ended match.
      // This removes all timing/race dependencies on room/match subscriptions.
      try{
        if (match && match.status === "ended" && state.role === "watch" && !state._matchWinShown) {
          const winner = (match.setsA > match.setsB) ? (match.nameA || "PLAYER A") : (match.nameB || "PLAYER B");
          state._matchWinShown = true;
          showMatchWinPopup(winner, match.setsA ?? 0, match.setsB ?? 0);
        }
      }catch(e){}
      $("finalSetsA").textContent = match.setsA;
      $("finalSetsB").textContent = match.setsB;

      // Names above final scores (for download image too)
      $("finalNameA").textContent = match.nameA || "Player A";
      $("finalNameB").textContent = match.nameB || "Player B";

      // Total match time
      const totalMs = (match.totalDurationMs != null)
        ? match.totalDurationMs
        : (match.endedAt && match.startedAt ? (match.endedAt - match.startedAt) : 0);
      $("totalTime").textContent = `Total time: ${fmtDur(totalMs)}`;

      const list = $("finalSetList");
      list.innerHTML = "";
      (match.sets || []).forEach((s) => {
        const el = document.createElement("div");
        el.className = "setItem";
        el.innerHTML = `
          <div class="setScoreLeft">
            <span class="chipA">${s.a}</span>
            <span class="vsep">|</span>
            <span class="chipB">${s.b}</span>
          </div>
          <div class="setTimeRight">(${fmtDur(s.durationMs || 0)})</div>
        `;
        list.appendChild(el);
      });
    }

    function canScoreThisMatch(match) {
      return state.role === "scorer" && match && match.ownerUid && uid && match.ownerUid === uid;
    }

    /*******
     * 6) Subscribe room -> current match
     *******/
    function subscribeMatch(matchId) {
      if (!matchId) return;
      if (currentMatchUnsub) { currentMatchUnsub(); currentMatchUnsub = null; }

      const matchRef = ref(db, `matches/${matchId}`);
      const handler = (snap) => {
        const m = snap.val();
        if (!m) return;

        state.match = m;
        // Timeout reset on new match
        if (state._matchIdForTimeout !== matchId) { state._matchIdForTimeout = matchId; if (typeof resetTimeoutForNewMatch === 'function') resetTimeoutForNewMatch(); }

        // If another scorer owns it, force watch mode
        if (state.role === "scorer" && uid && m.ownerUid && m.ownerUid !== uid) {
          state.role = "watch";
          $("roleBadge").textContent = state.role;
    // Ask name once (used for presence list)
    ensureDisplayName();
          $("modeText").textContent = state.role;
          $("scorerControls").style.display = "none";
          updatePresenceRole();
          toast("Another scorer owns this match.", "You are in watch mode.");
        }

        
if (m.status === "ended") {
          // Show a big MATCH WON celebration ONLY when we actually witnessed it end (not when joining late).
          const endedNow = (state._seenMatchOnce && state._prevMatchStatus !== "ended");
          const winner = (m.setsA > m.setsB) ? (m.nameA || "PLAYER A") : (m.nameB || "PLAYER B");

          if (endedNow) {
            showMatchWinPopup(winner, m.setsA ?? 0, m.setsB ?? 0);
            setTimeout(() => {
              showView("result");
              renderResult(m);
            }, 3800);
          } else {
            showView("result");
            renderResult(m);
          }
        } else {
          showView("live");
          renderLive(m);
        try{ if (typeof applyTimeoutFromMatch === 'function') applyTimeoutFromMatch(m); }catch(e){}
        }

        state._seenMatchOnce = true;
        state._prevMatchStatus = m.status;


        $("scorerControls").style.display = canScoreThisMatch(m) ? "" : "none";
      };

      onValue(matchRef, handler);
      currentMatchUnsub = () => off(matchRef, "value", handler);
    }

    function applyRoomSnapshot(room){
      lastRoomSnapshot = room || null;

      const roomState = (room && room.status) ? room.status : "idle";
      const msg = (room && room.message) ? room.message : "";
      setRoomStateBadge(roomState, msg);
      
      // Reliable MATCH WON popup for BOTH scorer and watchers (room-driven, no race conditions)
      if (room && room.status === "ended" && room.endedAt && room.winnerName) {
        if (state._lastEndedAt !== room.endedAt) {
          state._lastEndedAt = room.endedAt;
          showMatchWinPopup(room.winnerName, room.finalSetsA ?? 0, room.finalSetsB ?? 0);
          setTimeout(() => {
            showView("result");
            // If match snapshot is still available, render full result
            if (state.match) renderResult(state.match);
          }, 3800);
        }
      }

      
      // Room-level MATCH WON popup (reliable for watchers)
      if (room && room.status === "ended" && room.winnerName && !state._matchWinShown) {
        state._matchWinShown = true;
        showMatchWinPopup(room.winnerName, room.finalSetsA ?? 0, room.finalSetsB ?? 0);
        setTimeout(() => {
          // Prefer showing result view; match subscription will render details if still available
          showView("result");
          if (state.match) renderResult(state.match);
        }, 3800);
      }


      
      // No current match:
      // - If the room is ENDED, keep viewers on the result flow (do NOT bounce watchers to setup, which would hide the popup).
      // - Otherwise, show setup.
      if (!room || !room.currentMatchId) {
        currentMatchId = null;

        if (room && room.status === "ended") {
          // Keep the UI on result view; popup (if any) remains visible.
          showView("result");
        } else {
          showView("setup");
        }
        return;
      }


      // Room has active match
      if (room.currentMatchId !== currentMatchId) {
        currentMatchId = room.currentMatchId;
        subscribeMatch(currentMatchId);
      }
    }

    onValue(roomRef, (snap) => applyRoomSnapshot(snap.val()));

    /*******
     * 7) Auth + start
     *******/
    setStatus("Connecting...", "warn");

    onAuthStateChanged(auth, async (user) => {
      if (user) {
        uid = user.uid;
        setStatus("Connected", "ok");
        await startPresence();
        subscribePresence();
      }
    });

    try {
      await signInAnonymously(auth);
      // status will be updated via onAuthStateChanged + presence
      } catch (e) {
      setStatus("Auth failed", "bad");
      toast("Auth failed", "Enable Anonymous Auth in Firebase.");
      console.error(e);
    }

    /*******
     * 8) Start match (scorer)
     *******/
    async function setRoomStatusPatch(patch){
      try{
        await update(roomRef, { ...patch, updatedAt: serverTimestamp() });
      }catch(e){
        console.error(e);
      }
    }

    $("startBtn").addEventListener("click", async () => {
      state.role = "scorer";
      $("roleBadge").textContent = state.role;
    // Ask name once (used for presence list)
    ensureDisplayName();
      $("modeText").textContent = state.role;
      updatePresenceRole();

      const pin = ($("pin").value || "").trim();
      if (!pin) { toast("Enter scorer PIN"); return; }

      const nameA = clampName($("nameA").value, "First player");
      const nameB = clampName($("nameB").value, "Second player");
      const tossWinner = $("tossWinner").value === "B" ? "B" : "A";
      const bestOf = Number($("bestOf").value || 5);
      const pointsToWin = Number($("pointsToWin").value || 11);

      const matchId = `m_${Date.now()}_${Math.random().toString(16).slice(2,8)}`;

      const match = {
        matchId,
        roomId,
        ownerUid: uid,
        pinHash: btoa(pin).slice(0,16), // casual use only
        nameA, nameB,
        bestOf,
        pointsToWin,
        tossWinner,
        gameStartServer: tossWinner,
        scoreA: 0,
        scoreB: 0,
        sets: [],
        setsA: 0,
        setsB: 0,
        gameIndex: 1,
        status: "live",
        startedAt: Date.now(),
        gameStartedAt: Date.now(),
        createdAt: Date.now(),
        updatedAt: Date.now()
      };

      try {
        await set(ref(db, `matches/${matchId}`), match);
        await setRoomStatusPatch({ currentMatchId: matchId, status: "live", message: "Match is live" });
        state.undoStack = [];
        toast("Match started");
      } catch (e) {
        console.error(e);
        setStatus("Permission denied", "bad");
        toast("PERMISSION_DENIED", "Check Rules + Anonymous Auth.");
      }
    });

    /*******
     * 9) Scoring actions (owner only)
     *******/
    async function updateMatchAtomic(fn) {
      if (!currentMatchId) return;
      const matchRef = ref(db, `matches/${currentMatchId}`);

      try {
        await runTransaction(matchRef, (cur) => {
          if (!cur) return cur;
          if (!uid || cur.ownerUid !== uid) return cur; // owner-only
          const next = fn(clone(cur));
          next.updatedAt = Date.now();
          return next;
        });
      } catch (e) {
        console.error(e);
        toast("Update failed", "Permission or connectivity issue.");
      }
    }

    function pushUndo(snapshot) {
      state.undoStack.push(snapshot);
      if (state.undoStack.length > 25) state.undoStack.shift();
    }

    async function addPoint(which) {
      const m = state.match;
      if (!canScoreThisMatch(m)) { toast("Not scorer for this match"); return; }

      pushUndo(clone(m));


      // Reliability: decide locally whether this point will end the current game.
      // (Sometimes realtime updates can skip an intermediate render; this guarantees the popup triggers.)
      const preA = Number(m.scoreA || 0);
      const preB = Number(m.scoreB || 0);
      const nextA = preA + (which === "A" ? 1 : 0);
      const nextB = preB + (which === "B" ? 1 : 0);
      const gameWillEnd = isGameWon(nextA, nextB, m.pointsToWin);
      const gameWinnerName = gameWillEnd
        ? (nextA > nextB ? (m.nameA || "PLAYER A") : (m.nameB || "PLAYER B"))
        : null;

      const nextSetsA = gameWillEnd ? (Number(m.setsA || 0) + (nextA > nextB ? 1 : 0)) : Number(m.setsA || 0);
      const nextSetsB = gameWillEnd ? (Number(m.setsB || 0) + (nextB > nextA ? 1 : 0)) : Number(m.setsB || 0);

      await updateMatchAtomic((cur) => {
        if (cur.status !== "live") return cur;

        if (which === "A") cur.scoreA += 1;
        else cur.scoreB += 1;

        if (isGameWon(cur.scoreA, cur.scoreB, cur.pointsToWin)) {
          cur.sets = cur.sets || [];
          const dur = Date.now() - (cur.gameStartedAt || cur.startedAt || Date.now());
          cur.sets.push({ a: cur.scoreA, b: cur.scoreB, durationMs: dur });

          if (cur.scoreA > cur.scoreB) cur.setsA += 1;
          else cur.setsB += 1;

          cur.scoreA = 0;
          cur.scoreB = 0;
          // Next game starts with the other player serving (official TT rule).
          const gss = (cur.gameStartServer || cur.tossWinner || "A");
          cur.gameStartServer = (gss === "A") ? "B" : "A";
          cur.gameIndex = (cur.sets.length + 1);
          cur.gameStartedAt = Date.now();

          const need = setsToWin(cur.bestOf);
          if (cur.setsA >= need || cur.setsB >= need) {
            cur.status = "ended";
            cur.endedAt = Date.now();
            cur.totalDurationMs = (cur.startedAt ? (cur.endedAt - cur.startedAt) : 0);
          }
        }
        return cur;
      });


      if (gameWillEnd) {
        showGameWinPopup(gameWinnerName, nextSetsA, nextSetsB);
      }

      // If it ended, mark room ended too (watchers will see result via match subscription)
      const m2 = state.match;
      if (m2 && m2.status === "ended") {
        await setRoomStatusPatch({ status: "ended", message: "Match ended" });
      }
    }

    $("ptA").addEventListener("click", () => addPoint("A"));
    $("ptB").addEventListener("click", () => addPoint("B"));

    $("undoBtn").addEventListener("click", async () => {
      const m = state.match;
      if (!canScoreThisMatch(m)) { toast("Not scorer"); return; }
      const prev = state.undoStack.pop();
      if (!prev) { toast("Nothing to undo"); return; }

      try {
        await set(ref(db, `matches/${currentMatchId}`), { ...prev, updatedAt: Date.now() });
        toast("Undone");
      } catch (e) {
        console.error(e);
        toast("Undo failed");
      }
    });

    $("swapServeBtn").addEventListener("click", async () => {
      const m = state.match;
      if (!canScoreThisMatch(m)) { toast("Not scorer"); return; }

      pushUndo(clone(m));

      await updateMatchAtomic((cur) => {
        const next = (cur.gameStartServer || cur.tossWinner) === "A" ? "B" : "A";
        cur.gameStartServer = next;
        // keep backward compatibility with existing "tossWinner" usage elsewhere
        cur.tossWinner = next;
        return cur;
      });
      toast("Serve swapped");
    });

    $("endMatchBtn").addEventListener("click", async () => {
      const m = state.match;
      if (!canScoreThisMatch(m)) { toast("Not scorer"); return; }

      await updateMatchAtomic((cur) => {
        cur.status = "ended";
        cur.endedAt = Date.now();
        cur.totalDurationMs = (cur.startedAt ? (cur.endedAt - cur.startedAt) : 0);
        return cur;
      });
      
      // Write room-level summary so watchers can ALWAYS show MATCH WON popup
      const endedMatch = state.match;
      const setsA = (endedMatch && (endedMatch.setsA ?? endedMatch.setsA === 0)) ? (endedMatch.setsA ?? 0) : 0;
      const setsB = (endedMatch && (endedMatch.setsB ?? endedMatch.setsB === 0)) ? (endedMatch.setsB ?? 0) : 0;
      const winnerName = (setsA > setsB) ? ((endedMatch && endedMatch.nameA) || "PLAYER A")
                                         : ((endedMatch && endedMatch.nameB) || "PLAYER B");
      const endedAtRoom = Date.now();

      await setRoomStatusPatch({
        status: "ended",
        message: "Match ended",
        lastMatchId: currentMatchId || null,
        winnerName,
        finalSetsA: setsA,
        finalSetsB: setsB,
        endedAt: endedAtRoom
      });
toast("Match ended");
    });

    // Cancel: removes currentMatchId so watchers go back to setup and see "cancelled"
    $("cancelMatchBtn").addEventListener("click", async () => {
      const m = state.match;
      if (!canScoreThisMatch(m)) { toast("Not scorer"); return; }

      try{
        await setRoomStatusPatch({ currentMatchId: null, status: "cancelled", message: "Match cancelled", lastMatchId: currentMatchId || null });
        toast("Cancelled", "Watchers will see cancellation.");
        showView("setup");
      }catch(e){
        console.error(e);
        toast("Cancel failed");
      }
    });

    // Restart: keep same matchId but reset scores/sets to zero and room becomes live
    $("restartMatchBtn").addEventListener("click", async () => {
      const m = state.match;
      if (!canScoreThisMatch(m)) { toast("Not scorer"); return; }

      pushUndo(clone(m));

      await updateMatchAtomic((cur) => {
        cur.scoreA = 0;
        cur.scoreB = 0;
        cur.sets = [];
        cur.setsA = 0;
        cur.setsB = 0;
        cur.gameIndex = 1;
        cur.status = "live";
        return cur;
      });

      await setRoomStatusPatch({ status: "live", message: "Match restarted", currentMatchId: currentMatchId });
      toast("Restarted", "Scores reset to 0‚Äì0.");
    });

    // New match: goes to setup but does not change room until Start is pressed
    $("newMatchBtn").addEventListener("click", async () => {
      showView("setup");
      toast("Ready for new match");
      // Optional: show scheduled state so watchers know match is being prepared
      if (state.role === "scorer") {
        await setRoomStatusPatch({ currentMatchId: null, status: "scheduled", message: "Scorer is setting up a match" });
      }
    });

    $("resultNewMatchBtn").addEventListener("click", async () => {
      showView("setup");
      toast("Start a new match");
      if (state.role === "scorer") {
        await setRoomStatusPatch({ currentMatchId: null, status: "scheduled", message: "Scorer is setting up a match" });
      }
    });

    $("backToSetupBtn").addEventListener("click", () => {
      showView("setup");
    });

    /*******
     * 10) Download Scorecard (PNG)
     *******/
    async function downloadScorecard() {
      const panel = $("mainPanel");
      toast("Preparing download...");
      try {
        const canvas = await window.html2canvas(panel, {
          backgroundColor: null,
          scale: 2,
          useCORS: true
        });
        const dataUrl = canvas.toDataURL("image/png");

        const a = document.createElement("a");
        const ts = new Date().toISOString().replace(/[:.]/g,"-");
        a.download = `TTFL-scorecard-${roomId}-${ts}.png`;
        a.href = dataUrl;
        document.body.appendChild(a);
        a.click();
        a.remove();

        toast("Downloaded", "Scorecard saved as image.");
      } catch (e) {
        console.error(e);
        toast("Download failed", "Try Safari (best on iPhone).");
      }
    }
    $("downloadBtn").addEventListener("click", downloadScorecard);

    /*******
     * Timeout system (Additive)
     * - 1 timeout per player per match
     * - 60s popup freezes match interactions
     *******/
    const timeoutPopupWrap = $("timeoutPopupWrap");
    const timeoutTitle = $("timeoutTitle");
    const timeoutSub = $("timeoutSub");
    const timeoutTimerEl = $("timeoutTimer");
    const timeoutBlueBtn = $("timeoutBlueBtn");
    const timeoutOrangeBtn = $("timeoutOrangeBtn");
    const timeoutTagA = $("timeoutTagA");
    const timeoutTagB = $("timeoutTagB");

    function setTimeoutButtonsDisabled(){
      if (timeoutBlueBtn) timeoutBlueBtn.disabled = !!state.timeoutUsedA || !!state._timeoutActive;
      if (timeoutOrangeBtn) timeoutOrangeBtn.disabled = !!state.timeoutUsedB || !!state._timeoutActive;
    }

    function setFrozen(isFrozen){
      state._timeoutActive = !!isFrozen;
      const live = $("liveView");
      if (!live) return;
      if (isFrozen){
        live.style.pointerEvents = "none";
        if (timeoutPopupWrap) timeoutPopupWrap.style.pointerEvents = "auto";
      } else {
        live.style.pointerEvents = "";
      }
      setTimeoutButtonsDisabled();
    }

    function showTimeoutPopup(playerLabel){
      if (!timeoutPopupWrap) return;
      timeoutTitle.textContent = `${playerLabel} TOOK TIMEOUT`;
      timeoutSub.textContent = "Official 60-second timeout. Match is paused.";
      timeoutTimerEl.textContent = "60";
      timeoutTimerEl.classList.remove("warn");
      _restartOverlay(timeoutPopupWrap);
    }

    function hideTimeoutPopup(){
      timeoutPopupWrap && timeoutPopupWrap.classList.remove("show");
      timeoutTimerEl && timeoutTimerEl.classList.remove("warn");
    }

    
    
    function startTimeout(player){
      if (state._timeoutActive) return;
      if (player === "A" && state.timeoutUsedA) return;
      if (player === "B" && state.timeoutUsedB) return;

      // Immediate local UX (no waiting for network), then persist to match so all watchers see it.
      const startedAt = Date.now();
      const endsAt = startedAt + 60000;

      // Local reflect
      if (player === "A") state.timeoutUsedA = true;
      if (player === "B") state.timeoutUsedB = true;

      const local = state.match ? clone(state.match) : {};
      local.timeoutUsedA = local.timeoutUsedA || (player === "A");
      local.timeoutUsedB = local.timeoutUsedB || (player === "B");
      local.timeout = { active: true, by: player, startedAt, endsAt };
      try{ applyTimeoutFromMatch(local); }catch(e){}

      // Persist (owner/scorer only)
      updateMatchAtomic((m) => {
        m.timeoutUsedA = m.timeoutUsedA || (player === "A");
        m.timeoutUsedB = m.timeoutUsedB || (player === "B");
        m.timeout = { active: true, by: player, startedAt, endsAt };
        return m;
      });
    }
    // Expose for onclick / external wiring
    window.startTimeout = startTimeout;
</script>

<script>
/* =========================================================
   Timeout System Wiring (Additive, Non-breaking)
   - Adds missing listeners + watcher sync + timer + beeps
   ========================================================= */
(function(){
  // Defensive: only run if the timeout elements exist
  const $ = window.$ || ((id)=>document.getElementById(id));
  const timeoutPopupWrap = $("timeoutPopupWrap");
  const timeoutTitle = $("timeoutTitle");
  const timeoutSub = $("timeoutSub");
  const timeoutTimerEl = $("timeoutTimer");
  const timeoutBlueBtn = $("timeoutBlueBtn");
  const timeoutOrangeBtn = $("timeoutOrangeBtn");
  const timeoutTagA = $("timeoutTagA");
  const timeoutTagB = $("timeoutTagB");

  if (!timeoutPopupWrap || !timeoutTitle || !timeoutTimerEl) return;

  // Ensure state fields exist (older rooms / cached versions)
  window.state = window.state || {};
  const state = window.state;

  if (typeof state.timeoutUsedA !== "boolean") state.timeoutUsedA = false;
  if (typeof state.timeoutUsedB !== "boolean") state.timeoutUsedB = false;
  if (typeof state._timeoutActive !== "boolean") state._timeoutActive = false;
  if (typeof state._timeoutWarnPlayed !== "boolean") state._timeoutWarnPlayed = false;
  if (!("_timeoutTimerId" in state)) state._timeoutTimerId = null;
  if (!("_timeoutEndsAt" in state)) state._timeoutEndsAt = null;
  if (!("_timeoutLastBeepSec" in state)) state._timeoutLastBeepSec = null;
  if (!("_timeoutSeenEndsAt" in state)) state._timeoutSeenEndsAt = null;
  if (!("_timeoutSeenStartedAt" in state)) state._timeoutSeenStartedAt = null;
  if (!("_matchIdForTimeout" in state)) state._matchIdForTimeout = null;

  const TTFL_AUDIO = window.TTFL_AUDIO || {};
  const _restartOverlay = window._restartOverlay || function(el){ el.classList.remove("show"); void el.offsetWidth; el.classList.add("show"); };

  function setTimeoutButtonsDisabled(){
    if (timeoutBlueBtn) timeoutBlueBtn.disabled = !!state.timeoutUsedA || !!state._timeoutActive;
    if (timeoutOrangeBtn) timeoutOrangeBtn.disabled = !!state.timeoutUsedB || !!state._timeoutActive;
  }

  function setFrozen(isFrozen){
    state._timeoutActive = !!isFrozen;
    const live = $("liveView");
    if (live){
      if (isFrozen){
        live.style.pointerEvents = "none";
        timeoutPopupWrap.style.pointerEvents = "auto";
      } else {
        live.style.pointerEvents = "";
      }
    }
    setTimeoutButtonsDisabled();
  }

  function showTimeoutPopup(playerLabel){
    timeoutTitle.textContent = `${playerLabel} TOOK TIMEOUT`;
    timeoutSub.textContent = "Official 60-second timeout. Match is paused.";
    timeoutTimerEl.textContent = "60";
    timeoutTimerEl.classList.remove("warn");
    _restartOverlay(timeoutPopupWrap);
  }

  function hideTimeoutPopup(){
    timeoutPopupWrap.classList.remove("show");
    timeoutTimerEl.classList.remove("warn");
  }

  function ensureTimerLoop(){
    if (state._timeoutTimerId) return;
    state._timeoutTimerId = setInterval(() => {
      if (!state._timeoutEndsAt) return;

      const remainMs = Math.max(0, state._timeoutEndsAt - Date.now());
      const remainSec = Math.ceil(remainMs / 1000);

      timeoutTimerEl.textContent = String(remainSec);
      if (remainSec <= 5) timeoutTimerEl.classList.add("warn");
      else timeoutTimerEl.classList.remove("warn");

      // Beep every second from 55..6
      if (remainSec <= 55 && remainSec >= 1){
        if (state._timeoutLastBeepSec !== remainSec){
          state._timeoutLastBeepSec = remainSec;
          try{ TTFL_AUDIO.playTimeoutTick && TTFL_AUDIO.playTimeoutTick(); }catch(e){}
        }
      }

      // Final 5-second warning (one-time)
      if (remainSec <= 5 && !state._timeoutWarnPlayed){
        state._timeoutWarnPlayed = true;
        try{ TTFL_AUDIO.playTimeoutWarn5 && TTFL_AUDIO.playTimeoutWarn5(); }catch(e){}
      }

      if (remainMs <= 0){
        // end
        clearInterval(state._timeoutTimerId);
        state._timeoutTimerId = null;
        state._timeoutEndsAt = null;
        state._timeoutLastBeepSec = null;

        hideTimeoutPopup();
        setFrozen(false);
        setTimeoutButtonsDisabled();

        // Ensure T shows
        if (state.timeoutUsedA && timeoutTagA) timeoutTagA.classList.add("show");
        if (state.timeoutUsedB && timeoutTagB) timeoutTagB.classList.add("show");
      }
    }, 200);
  }

  function applyTimeoutFromMatch(match){
    if (!match) return;

    // Sync used flags for BOTH scorer and watchers
    if (typeof match.timeoutUsedA === "boolean") state.timeoutUsedA = match.timeoutUsedA;
    if (typeof match.timeoutUsedB === "boolean") state.timeoutUsedB = match.timeoutUsedB;

    if (state.timeoutUsedA && timeoutTagA) timeoutTagA.classList.add("show");
    if (state.timeoutUsedB && timeoutTagB) timeoutTagB.classList.add("show");

    const to = match.timeout;
    if (to && to.active && to.endsAt){
      const playerLabel = (to.by === "A") ? (match.nameA || "PLAYER A") : (match.nameB || "PLAYER B");

      // Play start sound once per timeout instance on each client
      if (state._timeoutSeenEndsAt !== to.endsAt){
        state._timeoutSeenEndsAt = to.endsAt;
        state._timeoutWarnPlayed = false;
        state._timeoutLastBeepSec = null;
        try{ TTFL_AUDIO.playTimeoutStart && TTFL_AUDIO.playTimeoutStart(); }catch(e){}
      }

      state._timeoutEndsAt = to.endsAt;
      showTimeoutPopup(playerLabel);
      setFrozen(true);
      ensureTimerLoop();
    } else {
      // Not active
      if (state._timeoutTimerId){
        clearInterval(state._timeoutTimerId);
        state._timeoutTimerId = null;
      }
      state._timeoutEndsAt = null;
      state._timeoutLastBeepSec = null;
      hideTimeoutPopup();
      setFrozen(false);
      setTimeoutButtonsDisabled();
    }

    setTimeoutButtonsDisabled();
  }

  // Expose for other code paths (if they call it)
  window.applyTimeoutFromMatch = window.applyTimeoutFromMatch || applyTimeoutFromMatch;

  // Attach click listeners (scorer controls only; watchers won't have these buttons)
  if (timeoutBlueBtn && !timeoutBlueBtn._bound){
    timeoutBlueBtn._bound = true;
    timeoutBlueBtn.addEventListener("click", () => {
      if (typeof window.startTimeout === "function") window.startTimeout("A");
      else if (typeof startTimeout === "function") startTimeout("A");
    });
  }
  if (timeoutOrangeBtn && !timeoutOrangeBtn._bound){
    timeoutOrangeBtn._bound = true;
    timeoutOrangeBtn.addEventListener("click", () => {
      if (typeof window.startTimeout === "function") window.startTimeout("B");
      else if (typeof startTimeout === "function") startTimeout("B");
    });
  }

  // Observe match changes (additive; avoids touching core subscribe logic)
  let lastMatchId = null;
  let lastSnapshot = null;
  setInterval(() => {
    try{
      const m = state.match;
      const mid = (m && (m.id || m.matchId)) || window.currentMatchId || null;

      if (mid && mid !== lastMatchId){
        lastMatchId = mid;
        // reset local timeout view for new match
        state._timeoutSeenEndsAt = null;
        state._timeoutWarnPlayed = false;
        state._timeoutLastBeepSec = null;
        hideTimeoutPopup();
        setFrozen(false);
      }

      // Only apply if snapshot changed (cheap hash)
      if (m && m !== lastSnapshot){
        lastSnapshot = m;
        applyTimeoutFromMatch(m);
      }
    }catch(e){}
  }, 250);

  // initial
  setTimeoutButtonsDisabled();
})();
</script>



<script>
// Hide Connection box in watcher mode ONLY
document.addEventListener("DOMContentLoaded", function () {
  try {
    const params = new URLSearchParams(window.location.search);
    const role = params.get("role");
    if (role && (role.toLowerCase() === "watcher" || role.toLowerCase() === "watch")) {
      const connBox = document.querySelector(".connectionBox, #connectionBox");
      if (connBox) connBox.style.display = "none";
    }
  } catch (e) {}
});
</script>


  <!-- Timeout Popup (Additive) -->
  <div class="timeoutPopupWrap" id="timeoutPopupWrap" aria-live="polite" aria-atomic="true">
    <div class="timeoutPopup" role="dialog" aria-modal="true" aria-label="Timeout">
      <h3 class="timeoutTitle" id="timeoutTitle">TIMEOUT</h3>
      <p class="timeoutSub" id="timeoutSub">Match paused for official timeout.</p>
      <div class="timeoutTimer" id="timeoutTimer">60</div>
    </div>
  </div>
</body>
</html>